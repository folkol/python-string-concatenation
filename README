Microbenchmarks
Python String Concatenation

waymoot.org: Efficient String Concatenation in Python â€” An assessment of the performance of several methods

Introduction: Building long strings in the Python progamming language can sometimes result in very slow running code. In this article I investigate the computational performance of various string concatenation methods.

For this comparison I required a test problem that calls for the construction of very long strings out of a large number of segments. It should not do much other computation, so that the measured performance is dependent only on the string operation performance.

Aside: How determine the Sample Size?

loop_count = 20000
			ops/s	 	process size (kB)
Method 1	3770	 	2424
Method 2	2230	 	2424
Method 3	29,600	 	2452
Method 4	83,700	 	3028
Method 5	90,900	 	2536
Method 6	119,800	 	3000

loop_count = 500000
			ops/s	 	process size (kB)
Method 3	17,100	 	8,016
Method 4	74,800	 	22,872
Method 5	94,900	 	10,480
Method 6	102,100	 	22,844

Conclusions

Use method 6 in most real programs.


Efficient String Concatenation in Python (2016 edition)

Builds on top of the old article, with small changes due to the timing module not being available.


Method 1: simple concatenation: s1 += s2

Method 2: concatenation using MutableString (s1 += s2, where s1 is a MutableString)

Method 3: appending to a long array of char

Method 4: building a list of strings, then calling "".join()

Method 5: writing to a cStringIO buffer in memory using write()

Method 6: same as Method 4 but using a list comprehension inline

The results for Python 2.2.1 are below:

runtime (ms) 	concatenations per second 
Method 1 	55.11	362,910
Method 2 	74.67	267,852
Method 3 	10.80	1,851,337
Method 4 	6.21	3,220,611
Method 5 	8.11	2,467,612
Method 6 	5.42	3,694,808

So in Python 2.2.1 the list comprehension method was the fastest by a pretty clear margin. However when I re-ran using 2.7.12 things turned out very differently:

runtime (ms)	concatenations per second
Method 1	1.7995	11,113,977
Method 2	90.1073	221,957
Method 3	3.9557	5,055,967
Method 4	2.1804	9,172,689
Method 5	4.8047	4,162,585
Method 6	1.4191	14,093,289


+- Patch #980695:  Implements efficient string concatenation for statements
+  of the form s=s+t and s+=t.  This will vary across implementations.
+  Accordingly, the str.join() method is strongly preferred for performance
+  sensitive code.

commit 52a21b8e65e2a231595cfec639701266202438a2
Author: Raymond Hettinger <python@rcn.com>
Date:   Fri Aug 6 18:43:09 2004 +0000

    SF patch #980695:  efficient string concatenation
    (Original patch by Armin Rigo).

 virtual memory size

 http://fa.bianp.net/blog/2013/different-ways-to-get-memory-consumption-or-lessons-learned-from-memory_profiler/


On python 2.7.15 on docker for mac

(venv)master$ for i in {1..6}; do docker run --rm -v `pwd`/maclemon.py:/maclemon.py  python:2.7 python maclemon.py $i; done
method 1
time 6.27183914185 ms
output size  86 kb
process size 26640 kb

method 2
time 132.327079773 ms
output size  86 kb
process size 35656 kb

method 3
time 9.03797149658 ms
output size  86 kb
process size 28736 kb

method 4
time 6.8690776825 ms
output size  86 kb
process size 27688 kb

method 5
time 8.92305374146 ms
output size  86 kb
process size 26772 kb

method 6
time 6.41894340515 ms
output size  86 kb
process size 26920 kb


Move ps-subprocessess outside of the time measurement.

(venv)master$ for i in {1..6}; do docker run --rm -v `pwd`/maclemon.py:/maclemon.py  python:2.7 python maclemon.py $i; done
method 1
time 2.51483917236 ms
output size  86 kb
process size 26648 kb

method 2
time 128.169059753 ms
output size  86 kb
process size 35672 kb

method 3
time 4.55188751221 ms
output size  86 kb
process size 28936 kb

method 4
time 2.76112556458 ms
output size  86 kb
process size 26924 kb

method 5
time 8.16178321838 ms
output size  86 kb
process size 26648 kb

method 6
time 1.64890289307 ms
output size  86 kb
process size 26924 kb

Run 2:

(venv)master$ for i in {1..6}; do docker run --rm -v `pwd`/maclemon.py:/maclemon.py  python:2.7 python maclemon.py $i; done
method 1
time 4.97484207153 ms
output size  86 kb
process size  6372 kb

method 2
time 126.070022583 ms
output size  86 kb
process size  7192 kb

method 3
time 4.6820640564 ms
output size  86 kb
process size  6560 kb

method 4
time 3.37409973145 ms
output size  86 kb
process size  6700 kb

method 5
time 5.36012649536 ms
output size  86 kb
process size  6332 kb

method 6
time 1.78790092468 ms
output size  86 kb
process size  6836 kb


Python 2 on mac:

(venv)master$ for i in {1..6}; do python maclemon.py $i; done
method 1
time 2.14195251465 ms
output size  86 kb
process size   3744 kb

method 2
time 78.3200263977 ms
output size  86 kb
process size   5200 kb

method 3
time 6.11805915833 ms
output size  86 kb
process size   3720 kb

method 4
time 3.37505340576 ms
output size  86 kb
process size   4144 kb

method 5
time 6.92296028137 ms
output size  86 kb
process size   3940 kb

method 6
time 2.11215019226 ms
output size  86 kb
process size   4112 kb



Ran 2to3 on maclemon.py

Method 2 and 3 does not work in Python 3.

(venv) master$ for i in 1 4 5 6; do python maclemon.py $i; done
method 1
time 4.891872406005859 ms
output size  86.806640625 kb
process size   6888 kb

method 4
time 5.238056182861328 ms
output size  86.806640625 kb
process size   7456 kb

method 5
time 5.697011947631836 ms
output size  86.806640625 kb
process size   7284 kb

method 6
time 4.332065582275391 ms
output size  86.806640625 kb
process size   7396 kb



Pre-calculate the string segments.

method 1
time 1.9528865814208984 ms
output size  86.806640625 kb
process size   8460 kb

method 4
time 0.30422210693359375 ms
output size  86.806640625 kb
process size   8492 kb

method 5
time 2.2428035736083984 ms
output size  86.806640625 kb
process size   8592 kb

method 6
time 0.26607513427734375 ms
output size  86.806640625 kb
process size   8464 kb


(venv) master$ for i in 1 4 5 6; do python maclemon.py $i; done
method 1
time 1.9071102142333984 ms
output size  86.806640625 kb
process size   8556 kb

method 4
time 0.2818107604980469 ms
output size  86.806640625 kb
process size   8408 kb

method 5
time 2.0432472229003906 ms
output size  86.806640625 kb
process size   8544 kb

method 6
time 0.24390220642089844 ms
output size  86.806640625 kb
process size   8412 kb



Plot histogram of times, same graph.

plot how they scale with loop_count

Maybe area-chart where we plot max and min value?



Use timeit with number=1 and high repeat.